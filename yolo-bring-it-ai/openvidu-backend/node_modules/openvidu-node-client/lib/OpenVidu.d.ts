import { AxiosError } from 'axios';
import { Recording } from './Recording';
import { RecordingProperties } from './RecordingProperties';
import { Session } from './Session';
import { SessionProperties } from './SessionProperties';
/**
 * @hidden
 */
interface HttpError {
    message?: string;
    response?: any;
    request?: any;
    status?: number;
}
export declare class OpenVidu {
    private hostname;
    private Buffer;
    /**
     * @hidden
     */
    host: string;
    /**
     * @hidden
     */
    basicAuth: string;
    /**
     * @hidden
     */
    static readonly API_PATH: string;
    /**
     * @hidden
     */
    static readonly API_SESSIONS: string;
    /**
     * @hidden
     */
    static readonly API_TOKENS: string;
    /**
     * @hidden
     */
    static readonly API_RECORDINGS: string;
    /**
     * @hidden
     */
    static readonly API_RECORDINGS_START: string;
    /**
     * @hidden
     */
    static readonly API_RECORDINGS_STOP: string;
    /**
     * @hidden
     */
    static readonly API_BROADCAST: string;
    /**
     * @hidden
     */
    static readonly API_BROADCAST_START: string;
    /**
     * @hidden
     */
    static readonly API_BROADCAST_STOP: string;
    /**
     * Array of active sessions. **This value will remain unchanged since the last time method {@link OpenVidu.fetch}
     * was called**. Exceptions to this rule are:
     *
     * - Calling {@link OpenVidu.createSession} automatically adds the new Session object to the local collection.
     * - Calling {@link Session.fetch} updates that specific Session status
     * - Calling {@link Session.close} automatically removes the Session from the list of active Sessions
     * - Calling {@link Session.forceDisconnect} automatically updates the inner affected connections for that specific Session
     * - Calling {@link Session.forceUnpublish} also automatically updates the inner affected connections for that specific Session
     * - Calling {@link Session.updateConnection} automatically updates the inner affected connection for that specific Session
     * - Calling {@link OpenVidu.startRecording} and {@link OpenVidu.stopRecording} automatically updates the recording status of the Session ({@link Session.recording})
     *
     * To get the array of active sessions with their current actual value, you must call {@link OpenVidu.fetch} before consulting
     * property {@link activeSessions}
     */
    activeSessions: Session[];
    /**
     * @param hostname URL where your OpenVidu deployment is up an running.
     *                 It must be the full URL (e.g. `https://12.34.56.78:1234/`)
     *
     * @param secret Secret configured in your OpenVidu deployment
     */
    constructor(hostname: string, secret: string);
    /**
     * Creates an OpenVidu session. The session identifier will be available at property {@link Session.sessionId}
     *
     * @returns A Promise that is resolved to the {@link Session} if success and rejected with an
     * [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object if not.
     * This Error object has as `message` property with a status code carrying a specific meaning
     * (see [REST API](/en/stable/reference-docs/REST-API/#post-recording-start)).
     *
     * This method will never return an Error with status `409`. If a session with the same `customSessionId` already
     * exists in OpenVidu Server, a {@link Session.fetch} operation is performed in the background and the updated Session
     * object is returned.
     */
    createSession(properties?: SessionProperties): Promise<Session>;
    startRecording(sessionId: string): Promise<Recording>;
    startRecording(sessionId: string, name: string): Promise<Recording>;
    startRecording(sessionId: string, properties: RecordingProperties): Promise<Recording>;
    /**
     * Stops the recording of a {@link Session}
     *
     * @param recordingId The `id` property of the {@link Recording} you want to stop
     *
     * @returns A Promise that is resolved to the {@link Recording} if it successfully stopped and rejected with an
     * [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object if not.
     * This Error object has as `message` property with a status code carrying a specific meaning
     * (see [REST API](/en/stable/reference-docs/REST-API/#post-recording-stop)).
     */
    stopRecording(recordingId: string): Promise<Recording>;
    /**
     * Gets an existing {@link Recording}
     *
     * @param recordingId The `id` property of the {@link Recording} you want to retrieve
     *
     * @returns A Promise that is resolved to the {@link Recording} if it successfully stopped and rejected with an
     * [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object if not.
     * This Error object has as `message` property with a status code carrying a specific meaning
     * (see [REST API](/en/stable/reference-docs/REST-API/#get-recording)).
     */
    getRecording(recordingId: string): Promise<Recording>;
    /**
     * Lists all existing recordings
     *
     * @returns A Promise that is resolved to an array with all existing recordings
     */
    listRecordings(): Promise<Recording[]>;
    /**
     * Deletes a {@link Recording}. The recording must have status `stopped`, `ready` or `failed`
     *
     * @param recordingId
     *
     * @returns A Promise that is resolved if the Recording was successfully deleted and rejected with an
     * [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object if not.
     * This Error object has as `message` property with a status code carrying a specific meaning
     * (see [REST API](/en/stable/reference-docs/REST-API/#delete-recording)).
     */
    deleteRecording(recordingId: string): Promise<Error>;
    startBroadcast(sessionId: string, broadcastUrl: string): Promise<void>;
    startBroadcast(sessionId: string, broadcastUrl: string, properties: RecordingProperties): Promise<void>;
    /**
     * Stops the broadcast of a {@link Session}
     *
     * @param sessionId The `sessionId` of the {@link Session} you want to stop broadcasting
     *
     * @returns A Promise that is resolved if the broadcast successfully stopped and rejected with an
     * [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object if not.
     * This Error object has as `message` property with a status code carrying a specific meaning
     * (see [REST API](/en/stable/reference-docs/REST-API/#stop-broadcast)).
     */
    stopBroadcast(sessionId: string): Promise<void>;
    /**
     * Updates every property of every active Session with the current status they have in OpenVidu Server.
     * After calling this method you can access the updated array of active sessions in {@link activeSessions}
     *
     * @returns A promise resolved to true if any Session status has changed with respect to the server, or to false if not.
     * This applies to any property or sub-property of any of the sessions locally stored in OpenVidu Node Client
     */
    fetch(): Promise<boolean>;
    /**
     * @hidden
     * @returns A map paring every existing sessionId with true or false depending on whether it has changed or not
     */
    fetchWebRtc(): Promise<any>;
    /**
     * Disable all logging except error level
     */
    enableProdMode(): void;
    private getBasicAuth;
    private setHostnameAndPort;
    /**
     * @hidden
     */
    handleError(error: AxiosError | HttpError, reject: (reason?: any) => void): void;
}
export {};
