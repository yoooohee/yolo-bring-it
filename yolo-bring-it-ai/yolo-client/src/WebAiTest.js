import React, { useRef, useEffect, useState } from "react";
import { FaceMesh } from "@mediapipe/face_mesh";
import { Camera } from "@mediapipe/camera_utils";
import Webcam from "react-webcam";

function WebAiTest() {
  const webcamRef = useRef(null);
  const [status, setStatus] = useState("ÎåÄÍ∏∞ Ï§ë...");
  const [eventMessage, setEventMessage] = useState("");
  const faceMeshRef = useRef(null);
  const cameraRef = useRef(null);
  const eyesClosedRef = useRef(false);
  const [memoryInfo, setMemoryInfo] = useState({
    usedJSHeapSize: 0,
    totalJSHeapSize: 0,
    jsHeapSizeLimit: 0,
  });
  const [cacheSize, setCacheSize] = useState("Calculating...");
  const [modelLoadSize, setModelLoadSize] = useState("Calculating...");
  const [forbiddenWord, setForbiddenWord] = useState("");
  const forbiddenWordRef = useRef("");
  const [transcription, setTranscription] = useState("");
  const finalTranscriptionRef = useRef("");
  const [gameMessage, setGameMessage] = useState("");
  const [score, setScore] = useState(0);
  const [isListening, setIsListening] = useState(false);
  const recognitionRef = useRef(null);
  const [targetTime, setTargetTime] = useState("");
  const [currentTime, setCurrentTime] = useState(0.00);
  const [isRunning, setIsRunning] = useState(false);
  const [isTimerHidden, setIsTimerHidden] = useState(false);
  const [difference, setDifference] = useState(null);
  const [timingMessage, setTimingMessage] = useState("");
  const startTimeRef = useRef(null);
  const timerIntervalRef = useRef(null);

  // Î∞òÏùë ÏÜçÎèÑ Í≤åÏûÑ ÏÉÅÌÉú
  const [isReactionStarted, setIsReactionStarted] = useState(false);
  const [screenColor, setScreenColor] = useState("red");
  const [reactionTime, setReactionTime] = useState(null);
  const [reactionMessage, setReactionMessage] = useState("");
  const reactionStartTimeRef = useRef(null);
  const greenTimeRef = useRef(null);
  const timeoutRef = useRef(null);

  // Effect 1: MediaPipe FaceMesh Î∞è Camera Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    faceMesh.onResults((results) => {
      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        const leftEyeUpper = landmarks[159];
        const leftEyeLower = landmarks[145];
        const leftDistance = Math.hypot(
          leftEyeUpper.x - leftEyeLower.x,
          leftEyeUpper.y - leftEyeLower.y,
          leftEyeUpper.z - leftEyeLower.z
        );
        const rightEyeUpper = landmarks[386];
        const rightEyeLower = landmarks[374];
        const rightDistance = Math.hypot(
          rightEyeUpper.x - rightEyeLower.x,
          rightEyeUpper.y - rightEyeLower.y,
          rightEyeUpper.z - rightEyeLower.z
        );
        const avgDistance = (leftDistance + rightDistance) / 2;
        const isClosed = avgDistance < 0.02;

        if (isClosed !== eyesClosedRef.current) {
          eyesClosedRef.current = isClosed;
          const status = isClosed ? "closed" : "opened";
          setEventMessage(status === "closed" ? "‚ö†Ô∏è ÎààÏùÑ Í∞êÏïòÏñ¥Ïöî!" : "üëç ÎààÏùÑ Îñ¥Ïñ¥Ïöî!");
          setTimeout(() => setEventMessage(""), 3000);
        }

        setStatus(eyesClosedRef.current ? "Îàà Í∞êÏùå" : "Îàà Îú∏");
      } else {
        setStatus("ÏñºÍµ¥ ÎØ∏Í∞êÏßÄ");
      }
    });

    faceMeshRef.current = faceMesh;

    if (webcamRef.current && webcamRef.current.video) {
      const camera = new Camera(webcamRef.current.video, {
        onFrame: async () => {
          await faceMesh.send({ image: webcamRef.current.video });
        },
        width: 320,
        height: 240,
      });
      cameraRef.current = camera;
      camera.start();
    }

    return () => {
      if (cameraRef.current) {
        cameraRef.current.stop();
      }
      if (faceMeshRef.current) {
        faceMeshRef.current.close();
      }
    };
  }, []);

  // Effect 2: Web Speech API Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.lang = "ko-KR";
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;

      recognitionRef.current.onresult = (event) => {
        let interimTranscript = '';
        let newFinalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; ++i) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            newFinalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }

        console.log("New final transcript:", newFinalTranscript);
        console.log("Interim transcript:", interimTranscript);

        if (newFinalTranscript) {
          const lowerNewFinal = newFinalTranscript.toLowerCase();
          const forbiddenLower = forbiddenWordRef.current.toLowerCase();

          if (lowerNewFinal.includes(forbiddenLower)) {
            setScore(prev => {
              const newScore = prev - 1;
              if (newScore <= 0) {
                setGameMessage("OUT! Ï†êÏàòÍ∞Ä 0Ïù¥ ÎêòÏóàÏäµÎãàÎã§.");
                if (recognitionRef.current) recognitionRef.current.stop();
                setIsListening(false);
                return 0;
              }
              setGameMessage("Í∏àÏßÄ Îã®Ïñ¥ Í∞êÏßÄ! Ï†êÏàò -1");
              return newScore;
            });
          }

          finalTranscriptionRef.current += newFinalTranscript;
        }

        setTranscription(finalTranscriptionRef.current + interimTranscript);
      };

      recognitionRef.current.onend = () => {
        if (isListening) recognitionRef.current.start();
      };

      recognitionRef.current.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
        setGameMessage("Ïù∏Ïãù Ïò§Î•ò: " + event.error);
      };
    } else {
      setGameMessage("Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. ChromeÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.");
    }

    return () => {
      if (recognitionRef.current) recognitionRef.current.stop();
    };
  }, [isListening]);

  // Effect 3: Î©îÎ™®Î¶¨ Î∞è Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ
  useEffect(() => {
    const memoryInterval = setInterval(() => {
      if ('memory' in performance) {
        setMemoryInfo({
          usedJSHeapSize: (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
          totalJSHeapSize: (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + ' MB',
          jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + ' MB',
        });
      } else {
        setMemoryInfo({ usedJSHeapSize: 'Not supported', totalJSHeapSize: '', jsHeapSizeLimit: '' });
      }
    }, 2000);

    const calculateCacheSize = async () => {
      if ('caches' in window) {
        let totalSize = 0;
        const cacheNames = await caches.keys();
        for (const name of cacheNames) {
          const cache = await caches.open(name);
          const requests = await cache.keys();
          for (const request of requests) {
            const response = await cache.match(request);
            if (response) {
              const blob = await response.blob();
              totalSize += blob.size;
            }
          }
        }
        setCacheSize((totalSize / 1024 / 1024).toFixed(2) + ' MB');
      } else {
        setCacheSize('Not supported');
      }
    };
    calculateCacheSize();
    const cacheInterval = setInterval(calculateCacheSize, 5000);

    const calculateModelLoadSize = () => {
      const entries = performance.getEntriesByType("resource");
      let modelSize = 0;
      entries.forEach((entry) => {
        if (entry.name.includes("@mediapipe/face_mesh")) {
          modelSize += entry.transferSize || entry.decodedBodySize || 0;
        }
      });
      setModelLoadSize((modelSize / 1024 / 1024).toFixed(2) + ' MB');
    };

    calculateModelLoadSize();
    const observer = new PerformanceObserver((list) => {
      calculateModelLoadSize();
    });
    observer.observe({ entryTypes: ["resource"] });

    return () => {
      clearInterval(memoryInterval);
      clearInterval(cacheInterval);
      observer.disconnect();
    };
  }, []);

  // Effect 4: ÌÉÄÏù¥Î∞ç Í≤åÏûÑ Î°úÏßÅ
  useEffect(() => {
    if (isRunning) {
      startTimeRef.current = Date.now();
      timerIntervalRef.current = setInterval(() => {
        const elapsed = (Date.now() - startTimeRef.current) / 1000;
        setCurrentTime(parseFloat(elapsed.toFixed(2)));

        if (elapsed >= 5) {
          setIsTimerHidden(true);
        }
      }, 10);
    } else {
      clearInterval(timerIntervalRef.current);
    }

    return () => clearInterval(timerIntervalRef.current);
  }, [isRunning]);

  // Effect 5: Ïä§ÌéòÏù¥Ïä§Î∞î Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === " " && isRunning && isTimerHidden) {
        handleStopTimer();
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isRunning, isTimerHidden, currentTime, targetTime]);

  // Effect 6: Î∞òÏùë ÏÜçÎèÑ Í≤åÏûÑ Î°úÏßÅ
  useEffect(() => {
    if (isReactionStarted) {
      setScreenColor("red");
      setReactionTime(null);
      setReactionMessage("");
      reactionStartTimeRef.current = Date.now();

      // ÎûúÎç§ ÏãúÍ∞Ñ (2-5Ï¥à) ÌõÑ Ï¥àÎ°ùÏúºÎ°ú Î≥ÄÍ≤Ω
      const randomDelay = Math.floor(Math.random() * 3000) + 2000; // 2000ms ~ 5000ms
      timeoutRef.current = setTimeout(() => {
        setScreenColor("green");
        greenTimeRef.current = Date.now();
      }, randomDelay);
    } else {
      clearTimeout(timeoutRef.current);
    }

    return () => clearTimeout(timeoutRef.current);
  }, [isReactionStarted]);

  // Î∞òÏùë ÏÜçÎèÑ Í≤åÏûÑ ÏãúÏûë
  const startReactionTest = () => {
    setIsReactionStarted(true);
  };

  // Î∞òÏùë ÏÜçÎèÑ Í≤åÏûÑ Ï§ëÏßÄ (ÌÅ¥Î¶≠ Ïãú)
  const handleReactionClick = () => {
    if (!isReactionStarted || screenColor === "red") {
      setReactionMessage("ÎÑàÎ¨¥ ÏùºÏ∞ç ÌÅ¥Î¶≠! Ïã§Í≤© - Ïû¨ÏãúÏûëÌïòÏÑ∏Ïöî.");
      setIsReactionStarted(false);
      return;
    }

    const timeTaken = (Date.now() - greenTimeRef.current) / 1000;
    setReactionTime(timeTaken.toFixed(2));
    setReactionMessage(`Î∞òÏùë ÏÜçÎèÑ: ${timeTaken.toFixed(2)}Ï¥à - ${timeTaken < 0.3 ? "ÏäπÎ¶¨! (Îπ†Î¶Ñ)" : "Ìå®Î∞∞! (ÎäêÎ¶º)"}`);
    setIsReactionStarted(false);
  };

  const handleSetWord = () => {
    if (forbiddenWord) {
      forbiddenWordRef.current = forbiddenWord;
      finalTranscriptionRef.current = "";
      setTranscription("");
      setScore(10);
      setGameMessage("Í∏àÏßÄ Îã®Ïñ¥Í∞Ä ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§: " + forbiddenWord);
      setIsListening(true);
      if (recognitionRef.current) recognitionRef.current.start();
    }
  };

  const stopListening = () => {
    if (recognitionRef.current) recognitionRef.current.stop();
    setIsListening(false);
    finalTranscriptionRef.current = "";
    setTranscription("");
    setGameMessage("Ïù∏Ïãù Ï§ëÏßÄ");
  };

  const startTimer = () => {
    if (targetTime && parseFloat(targetTime) > 5) {
      setCurrentTime(0.00);
      setIsRunning(true);
      setIsTimerHidden(false);
      setDifference(null);
      setTimingMessage("");
    } else {
      setTimingMessage("ÌÉÄÍ≤ü ÏãúÍ∞ÑÏùÑ 5Ï¥à Ïù¥ÏÉÅÏúºÎ°ú ÏûÖÎ†•ÌïòÏÑ∏Ïöî.");
    }
  };

  const handleStopTimer = () => {
    setIsRunning(false);
    const target = parseFloat(targetTime);
    const diff = parseFloat((currentTime - target).toFixed(2));
    const sign = diff >= 0 ? "+" : "-";
    setDifference(`${sign}${Math.abs(diff).toFixed(2)}`);
    setTimingMessage(
      `ÌÉÄÍ≤ü: ${target.toFixed(2)}Ï¥à, Ïã§Ï†ú: ${currentTime.toFixed(2)}Ï¥à, Ï∞®Ïù¥: ${sign}${Math.abs(diff).toFixed(2)}Ï¥à - ${
        Math.abs(diff) < 0.5 ? "ÏäπÎ¶¨!" : "Ìå®Î∞∞!"
      }`
    );
  };

  return (
    <div style={{ padding: "2rem" }}>
      <h1>üß† WEBÏóê AIÎÑ£Í≥† ÌÖåÏä§Ìä∏</h1>
      <div style={{ border: "1px solid #ccc", padding: "1rem", width: "300px" }}>
        <h2>Ïã§ÏãúÍ∞Ñ Îàà Í∞êÍ∏∞ Í∞êÏßÄ (Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏö©)</h2>
        <Webcam
          audio={false}
          ref={webcamRef}
          screenshotFormat="image/jpeg"
          width={320}
          height={240}
          videoConstraints={{ width: 320, height: 240, facingMode: "user" }}
        />
        <p>ÏÉÅÌÉú: {status}</p>
        {eventMessage && <p style={{ color: "red" }}>{eventMessage}</p>}
      </div>
      <div style={{ marginTop: "2rem" }}>
        <h3>Î¶¨ÏÜåÏä§ ÏÇ¨Ïö© Ï†ïÎ≥¥ (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)</h3>
        <p>ÏÇ¨Ïö© Ï§ë Î©îÎ™®Î¶¨ (usedJSHeapSize): {memoryInfo.usedJSHeapSize}</p>
        <p>Ìï†ÎãπÎêú Î©îÎ™®Î¶¨ (totalJSHeapSize): {memoryInfo.totalJSHeapSize}</p>
        <p>Î©îÎ™®Î¶¨ ÌïúÎèÑ (jsHeapSizeLimit): {memoryInfo.jsHeapSizeLimit}</p>
        <p>Ï∫êÏãú ÌÅ¨Í∏∞ (Cache Storage): {cacheSize}</p>
        <p>MediaPipe Face Mesh Î™®Îç∏ Î°úÎìú/Ï∫êÏãú ÌÅ¨Í∏∞: {modelLoadSize}</p>
        <small>Ï∞∏Í≥†: Î™®Îç∏ Î∂ÄÌïòÎäî ÎÑ§Ìä∏ÏõåÌÅ¨(Ï¥àÍ∏∞ Î°úÎìú) ~7-10 MB, Îü∞ÌÉÄÏûÑ Î©îÎ™®Î¶¨ 50-150 MB.</small>
      </div>
      <div style={{ marginTop: "2rem", border: "1px solid #ccc", padding: "1rem", width: "300px" }}>
        <h2>üö´ Í∏àÏßÄ Îã®Ïñ¥ Í≤åÏûÑ (Î∏åÎùºÏö∞Ï†Ä AI)</h2>
        <input
          type="text"
          value={forbiddenWord}
          onChange={(e) => setForbiddenWord(e.target.value)}
          placeholder="Í∏àÏßÄ Îã®Ïñ¥ ÏûÖÎ†• (Ïòà: ÏóÑÏ§ÄÏãù)"
          style={{ width: "100%", marginBottom: "10px" }}
        />
        <button onClick={handleSetWord} disabled={isListening} style={{ width: "100%", marginBottom: "10px" }}>
          Í∏àÏßÄ Îã®Ïñ¥ ÏÑ§Ï†ï (ÏûêÎèô Ïù∏Ïãù ÏãúÏûë)
        </button>
        {isListening && (
          <button onClick={stopListening} style={{ width: "100%", marginBottom: "10px", backgroundColor: "red", color: "white" }}>
            Ïù∏Ïãù Ï§ëÏßÄ
          </button>
        )}
        <p>Ïù∏Ïãù ÌÖçÏä§Ìä∏: {transcription}</p>
        <p>Ï†êÏàò: {score}</p>
        <p>Î©îÏãúÏßÄ: {gameMessage}</p>
      </div>
      <div style={{ marginTop: "2rem", border: "1px solid #ccc", padding: "1rem", width: "300px" }}>
        <h2>‚è±Ô∏è ÌÉÄÏù¥Î∞ç Í≤åÏûÑ (Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏö©)</h2>
        <input
          type="number"
          value={targetTime}
          onChange={(e) => setTargetTime(e.target.value)}
          placeholder="ÌÉÄÍ≤ü Ï¥à ÏûÖÎ†• (Ïòà: 13)"
          step="0.01"
          style={{ width: "100%", marginBottom: "10px" }}
        />
        <button onClick={startTimer} disabled={isRunning} style={{ width: "100%", marginBottom: "10px" }}>
          ÏãúÏûë (ÌÉÄÏù¥Î®∏ Ïã§Ìñâ)
        </button>
        {isRunning && (
          <button onClick={handleStopTimer} style={{ width: "100%", marginBottom: "10px", backgroundColor: "red", color: "white" }}>
            Ï§ëÏßÄ
          </button>
        )}
        <p>ÌòÑÏû¨ ÏãúÍ∞Ñ: {isTimerHidden ? "Ïà®ÍπÄ" : currentTime.toFixed(2)}Ï¥à</p>
        {difference !== null && <p>Ï∞®Ïù¥: {difference}Ï¥à</p>}
        <p>Î©îÏãúÏßÄ: {timingMessage}</p>
        <small>Ïä§ÌéòÏù¥Ïä§Î∞î ÎòêÎäî Ï§ëÏßÄ Î≤ÑÌäº: 5Ï¥à ÌõÑ Ïà®ÍπÄ. ÌÉÄÍ≤üÍ≥º 0.5Ï¥à Ïù¥ÎÇ¥Î°ú ÎßûÏ∂îÎ©¥ ÏäπÎ¶¨!</small>
      </div>
      <div style={{ marginTop: "2rem", border: "1px solid #ccc", padding: "1rem", width: "300px" }}>
        <h2>‚ö° Î∞òÏùë ÏÜçÎèÑ ÌÖåÏä§Ìä∏ (Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏö©)</h2>
        <button onClick={startReactionTest} disabled={isReactionStarted} style={{ width: "100%", marginBottom: "10px" }}>
          ÏãúÏûë (Îπ®Í∞Ñ ÌôîÎ©¥ ÎåÄÍ∏∞)
        </button>
        <div
          style={{
            width: "100%",
            height: "200px",
            backgroundColor: screenColor,
            marginBottom: "10px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "white",
            fontSize: "1.5rem",
          }}
        >
          {screenColor === "red" ? "ÎåÄÍ∏∞ Ï§ë..." : "ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî!"}
        </div>
        <button onClick={handleReactionClick} disabled={!isReactionStarted} style={{ width: "100%", marginBottom: "10px" }}>
          ÌÅ¥Î¶≠!
        </button>
        {reactionTime !== null && <p>Î∞òÏùë ÏÜçÎèÑ: {reactionTime}Ï¥à</p>}
        <p>Î©îÏãúÏßÄ: {reactionMessage}</p>
        <small>Îπ®Í∞Ñ ÌôîÎ©¥ÏóêÏÑú ÎåÄÍ∏∞, Ï¥àÎ°ù ÎêòÎ©¥ ÌÅ¥Î¶≠. Í∞ÄÏû• Îπ†Î•∏ Î∞òÏùëÏù¥ ÏäπÎ¶¨! (Í∏∞Ï§Ä: 0.3Ï¥à ÎØ∏Îßå ÏäπÎ¶¨)</small>
      </div>
    </div>
  );
}

export default WebAiTest;